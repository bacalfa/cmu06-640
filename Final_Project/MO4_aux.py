#!/usr/bin/env python

'''
Auxiliary functions for MO4 EoS model.
Analytical expressions generated by Maple 16
'''

from numpy import exp, log, zeros, asarray, sort

def MO4_V0(b, c, d, V):
    '''
    Analytical equilibrium volume
    '''
    b = b.astype(complex)
    c = c.astype(complex)
    d = d.astype(complex)
    V0 = zeros((len(b),1))
    
    import warnings
    with warnings.catch_warnings():
        warnings.simplefilter("ignore") # Ignore complex-to-real casting warning
        V0[:,0] = log(-b/c/0.2e1)**3/d**3
    V0_vals = zeros((len(b),1))
    
    # Check the volume values that are valid
    for i in range(len(b)):
        v = [V0[i,0]]
        for vi in v:
            if (vi >= 0.0 and vi >= min(V) and vi <= max(V)):
                V0_vals[i] = vi
                break
    V0_vals_ind = (V0_vals != 0.0).any(axis=1)
    V0_vals = V0_vals[V0_vals_ind]
    return sort(V0_vals_ind), sort(asarray(V0_vals[:,0]))

def MO4_E0(a, b, c, d, V):
    '''
    Analytical equilibrium energy
    '''
    return sort(a+b*exp(d*V**(0.1e1/0.3e1))+c*exp(0.2e1*d*V**(0.1e1/0.3e1)))

def MO4_B0(b, c, d, V):
    '''
    Analytical equilibrium bulk modulus
    '''
    return sort(-0.2e1/0.9e1*b*d*V**(-0.2e1/0.3e1)*exp(d*V**(0.1e1/0.3e1))+b*d**2*exp(d*V**(0.1e1/0.3e1))*V**(-0.1e1/0.3e1)/0.9e1-0.4e1/0.9e1*c*d*exp(d*V**(0.1e1/0.3e1))**2*V**(-0.2e1/0.3e1)+0.4e1/0.9e1*c*d**2*exp(d*V**(0.1e1/0.3e1))**2*V**(-0.1e1/0.3e1))

def MO4_B0p(b, c, d, V):
    '''
    Analytical equilibrium first derivative of the bulk modulus
    '''
    return sort(-((4*b)-(3*b*d*V**(0.1e1/0.3e1))+(b*d**2*V**(0.2e1/0.3e1))+0.8e1*c*exp((d*V**(0.1e1/0.3e1)))-0.12e2*c*d*exp((d*V**(0.1e1/0.3e1)))*(V**(0.1e1/0.3e1))+0.8e1*c*(d**2)*exp((d*V**(0.1e1/0.3e1)))*(V**(0.2e1/0.3e1)))/V/(b+(b*d*V**(0.1e1/0.3e1))+0.2e1*c*exp((d*V**(0.1e1/0.3e1)))+0.4e1*c*d*exp((d*V**(0.1e1/0.3e1)))*(V**(0.1e1/0.3e1)))/0.3e1)